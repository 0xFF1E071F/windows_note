算法详解 

    Base64编码要求把3个8位字节（3*8=24）转化为4个6位的字节（4*6=24），之后在6位的前面补两个0，形成8位一个字节的形式。 
具体转化形式间下图： 
字符串“张3” 
11010101 11000101 00110011 

00110101 00011100 00010100 00110011 
表1 

可以这么考虑：把8位的字节连成一串110101011100010100110011 
然后每次顺序选6个出来之后再把这6二进制数前面再添加两个0，就成了一个新的字节。之后再选出6个来，再添加0，依此类推，直到24个二进制数全部被选完。 
让我们来看看实际结果： 

字符串“张3” 
11010101 HEX:D5 11000101 HEX:C5 00110011 HEX:33 

00110101 00011100 00010100 00110011 
字符’5’ 字符’^\’ 字符’^T’ 字符’3’ 
十进制53 十进制34 十进制20 十进制51 
表2 

这样“张3 ”这个字符串就被Base64表示为”5^\^T3”了么？。错！ 
Base64编码方式并不是单纯利用转化完的内容进行编码。像’^\’字符是控制字符，并不能通过计算机显示出来，在某些场合就不能使用了。Base64有其自身的编码表： 

Table 1: The Base64 Alphabet 
Value Encoding Value Encoding Value Encoding Value Encoding 
0 A 17 R 34 i 51 z 
1 B 18 S 35 j 52 0 
2 C 19 T 36 k 53 1 
3 D 20 U 37 l 54 2 
4 E 21 V 38 m 55 3 
5 F 22 W 39 n 56 4 
6 G 23 X 40 o 57 5 
7 H 24 Y 41 p 58 6 
8 I 25 Z 42 q 59 7 
9 J 26 a 43 r 60 8 
10 K 27 b 44 s 61 9 
11 L 28 c 45 t 62 + 
12 M 29 d 46 u 63 / 
13 N 30 e 47 v (pad) = 
14 O 31 f 48 w 
15 P 32 g 49 x 
16 Q 33 h 50 y 
表3 

这也是Base64名称的由来，而Base64编码的结果不是根据算法把编码变为高两位是0而低6为代表数据，而是变为了上表的形式，如”A”就有7位，而”a”就只有6位。表中，编码的编号对应的是得出的新字节的十进制值。因此，从表2可以得到对应的Base64编码： 

字符串“张3” 
11010101 HEX:D5 11000101 HEX:C5 00110011 HEX:33 

00110101 00011100 00010100 00110011 
字符’5’ 字符’^\’ 字符’^T’ 字符’3’ 
十进制53 十进制34 十进制20 十进制51 
字符’1’ 字符’i’ 字符’U’ 字符’z’ 
表4 

这样，字符串“张3”经过编码后就成了字符串“1iUz”了。 
Base64将3个字节转变为4个字节，因此，编码后的代码量（以字节为单位，下同）约比编码前的代码量多了1/3。之所以说是“约”，是因为如果代码量正好是3的整数倍，那么自然是多了1/3。但如果不是呢？ 
细心的人可能已经注意到了，在The Base64 Alphabet中的最后一个有一个(pad) =字符。这个字符的目的就是用来处理这个问题的。 
当代码量不是3的整数倍时，代码量/3的余数自然就是2或者1。转换的时候，结果不够6位的用0来补上相应的位置，之后再在6位的前面补两个0。转换完空出的结果就用就用“=”来补位。譬如结果若最后余下的为2个字节的“张”： 

字符串“张” 
11010101 HEX:D5 11000101 HEX:C5 

00110101 00011100 00010100 
十进制53 十进制34 十进制20 pad 
字符’1’ 字符’i’ 字符’U’ 字符’=’ 
表6 

这样，最后的2个字节被整理成了“1iU=”。 
同理，若原代码只剩下一个字节，那么将会添加两个“=”。只有这两种情况，所以，Base64的编码最多会在编码结尾有两个“=” 
